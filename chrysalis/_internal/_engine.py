import pickle
import sqlite3
from collections.abc import Callable
from pathlib import Path

import duckdb

from chrysalis._internal import _tables as tables
from chrysalis._internal._relation import Relation
from chrysalis._internal._writer import TerminalUIWriter


class Engine[T, R]:
    """
    A class responsible for execution in metamorphic testing.

    The engine performs the actual execution of tests specificed by provided relation
    chains. To start, an engine is initialized with a static SUT (system under test) and
    input dataset. Then, the SUT can be tested using provided relation chains (likely
    generated by the search space class). Each relation chain is completely independent
    from all other relation chains, although multiple chains can be passed to `execute`
    at once for performance reasons. Additionally, all input data objects are tested for
    each specified relation chain.

    Performing metamorphic testing on a single input data object and relation chain
    combination is an iterative process. First, the results of execution of the SUT on
    the input data is determined. Then, the input data is transformed by the
    transformation specified by the first relation in the relation chain. Lastly, the
    result of execution of the SUT on the transformed data is compared to the previous
    result so it can be determined if each invariant for the given transformation held.
    This process is repeated for each transformation in the relation chain.

    Under the hood, a sqlite database is maintained which denotes the results of
    executing each relation chain on all of the input data. This data is kept so it can
    be used later for debugging if an invariant failed.
    """

    def __init__(
        self,
        sut: Callable[[T], R],
        input_data: list[T],
        sqlite_conn: sqlite3.Connection,
        sqlite_db: Path,
        writer: TerminalUIWriter,
        num_processes: int = 8,
    ):
        if num_processes > 1:
            raise NotImplementedError

        self._sut = sut
        self._conn = sqlite_conn
        self._sqlite_db = sqlite_db
        self._writer = writer
        self._num_processes = num_processes

        # Insert input data into database and store uuid for future reference.
        self._input_data: dict[str, T] = {}
        cur = self._conn.cursor()
        for input_obj in input_data:
            obj_id = self._insert_input_data(
                obj=input_obj,
                cursor=cur,
            )
            self._input_data[obj_id] = input_obj

    def _insert_input_data(
        self,
        obj: T,
        cursor: sqlite3.Cursor,
    ) -> str:
        """Insert a record into the `input_data` table."""
        input_data_id = tables.generate_uuid()
        cursor.execute(
            """
INSERT INTO input_data (id, obj)
VALUES (?, ?);
""",
            (input_data_id, pickle.dumps(obj)),
        )
        return input_data_id

    def _insert_applied_transformation(
        self,
        transformation: str,
        previous_applied_transformation: str | None,
        link_index: int,
        cursor: sqlite3.Cursor,
    ) -> str:
        """Insert a record into the `applied_transformation` table."""
        applied_transformation_id = tables.generate_uuid()
        cursor.execute(
            """
INSERT INTO applied_transformation
    (id, transformation, previous_applied_transformation, link_index)
VALUES
    (?, ?, ?, ?);
""",
            (
                applied_transformation_id,
                transformation,
                previous_applied_transformation,
                link_index,
            ),
        )
        return applied_transformation_id

    def _insert_failed_invariant(
        self,
        invariant: str,
        applied_transformation: str,
        input_data: str,
        cursor: sqlite3.Cursor,
    ) -> None:
        """Insert a record into the `failed_invariant` table."""
        invariant_id = tables.generate_uuid()
        cursor.execute(
            """
INSERT INTO failed_invariant (id, invariant, applied_transformation, input_data)
VALUES (?, ?, ?, ?);
        """,
            (invariant_id, invariant, applied_transformation, input_data),
        )

    def _execute_chain(
        self,
        relation_chain: list[Relation],
        cursor: sqlite3.Cursor,
    ) -> None:
        """Execute a relation chain and store all results in a provided database."""
        results: list[R] = []
        input_data_ids = list(self._input_data.keys())
        # TODO(nathanhuey44.gmail.com): The results of the SUT on the input data is
        # consistent for all relation chains and should be cached.
        for curr_input in self._input_data.values():
            # TODO(nathanhuey44@gmail.com): Catch errors, exit gracefully, and report
            # error.
            results.append(self._sut(curr_input))  # NOQA: PERF401

        previous_transformation_id: str | None = None
        previous_inputs = list(self._input_data.values())
        previous_results = results
        for link_index, relation in enumerate(relation_chain):
            current_inputs: list[T] = []
            for prev_input in previous_inputs:
                # TODO(nathanhuey44@gmail.com): Catch errors, exit gracefully, and
                # report error.
                current_inputs.append(  # NOQA: PERF401
                    relation.apply_transform(prev_input)
                )

            current_results: list[R] = []
            for curr_input in current_inputs:
                # TODO(nathanhuey44@gmail.com): Catch errors, exit gracefully, and
                # report error.
                current_results.append(self._sut(curr_input))  # NOQA: PERF401

            current_transformation_id = self._insert_applied_transformation(
                transformation=relation.transformation_id,
                previous_applied_transformation=previous_transformation_id,
                link_index=link_index,
                cursor=cursor,
            )
            failed_invariants: set[str] = set()
            for invariant_id, invariant in relation.invariants.items():
                for i, (prev_result, curr_result) in enumerate(
                    zip(previous_results, current_results, strict=True)
                ):
                    if not invariant(curr_result, prev_result):
                        failed_invariants.add(invariant.__name__)
                        self._insert_failed_invariant(
                            invariant=invariant_id,
                            applied_transformation=current_transformation_id,
                            input_data=input_data_ids[i],
                            cursor=cursor,
                        )

            if len(failed_invariants) == 0:
                self._writer.print_tested_relation(success=True)
            else:
                self._writer.print_tested_relation(success=False)
                self._writer.store_failed_relation(
                    failed_relation=relation.transformation_name,
                    failed_invariants=list(failed_invariants),
                )

            previous_transformation_id = current_transformation_id
            previous_inputs = current_inputs
            previous_results = current_results

    def execute(self, relation_chains: list[list[Relation]]) -> None:
        """
        Execute a list of provided relation chains and store the results.

        Execution of a relation chain involves iteratively applying transformations to
        each item in the input data and ensuring all invariants hold. At the moment,
        we do not anticipate transformations causing errors regardless of the input.
        It is important to note that multiple relations can reference the same
        transformation and thus multiple invariant can be checked during a single step
        in a relation chain.
        """
        # TODO(nathanhuey44@gmail.com): Implement a multi-process version of this
        # execute functionality using sqlite3 cursors.
        cursor = self._conn.cursor()
        for relation_chain in relation_chains:
            self._execute_chain(relation_chain=relation_chain, cursor=cursor)
        self._conn.commit()

    def results_to_duckdb(self) -> duckdb.DuckDBPyConnection:
        """
        Convert the sqlite3 database kept during execution into a duckdb database.

        Sqlite databases are designed for transactional processing, which fits our use
        case when inserting transaction and invariant records, especially if the program
        is using multiple cores. Once all the results have been accumulated, we can
        convert the database into a duckdb database due to duckdb's better performance
        on analytical queries and better data compression.
        """
        return tables.sqlite_to_duckdb(self._sqlite_db)
